/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ANAPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// api.ts
var ANAApiClient = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl.replace(/\/$/, "");
  }
  async checkStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/api/status`);
      return response.ok;
    } catch (e) {
      return false;
    }
  }
  async processNote(content, frontmatter, title) {
    const response = await fetch(`${this.baseUrl}/api/process`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content, frontmatter, title })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`API error: ${error}`);
    }
    return await response.json();
  }
  async answerQuestions(sessionId, answers) {
    const response = await fetch(`${this.baseUrl}/api/answer`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ session_id: sessionId, answers })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`API error: ${error}`);
    }
    return await response.json();
  }
  async saveNote(sessionId, outputPath, overwrite = false) {
    const response = await fetch(`${this.baseUrl}/api/save`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        session_id: sessionId,
        output_path: outputPath,
        overwrite
      })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`API error: ${error}`);
    }
    return await response.json();
  }
  async deleteSession(sessionId) {
    await fetch(`${this.baseUrl}/api/session/${sessionId}`, {
      method: "DELETE"
    });
  }
};

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  serverUrl: "http://127.0.0.1:8765",
  autoSave: false,
  showPreview: true,
  maxQuestions: 5
};
var ANASettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ANA - Atomic Note Architect" });
    containerEl.createEl("p", {
      text: "AI\uB97C \uC0AC\uC6A9\uD558\uC5EC \uC6D0\uC2DC \uB178\uD2B8\uB97C Zettelkasten \uC2A4\uD0C0\uC77C Atomic Note\uB85C \uBCC0\uD658\uD569\uB2C8\uB2E4.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc('ANA API \uC11C\uBC84 \uC8FC\uC18C (\uD130\uBBF8\uB110\uC5D0\uC11C "ana serve" \uC2E4\uD589 \uD544\uC694)').addText((text) => text.setPlaceholder("http://127.0.0.1:8765").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
      this.plugin.settings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Save").setDesc("\uCC98\uB9AC \uC644\uB8CC \uD6C4 \uC790\uB3D9\uC73C\uB85C \uB178\uD2B8 \uC800\uC7A5").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSave).onChange(async (value) => {
      this.plugin.settings.autoSave = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Preview").setDesc("\uC800\uC7A5 \uC804 \uC0DD\uC131\uB41C \uB178\uD2B8 \uBBF8\uB9AC\uBCF4\uAE30 \uD45C\uC2DC").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPreview).onChange(async (value) => {
      this.plugin.settings.showPreview = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Connection Test").setDesc("ANA \uC11C\uBC84 \uC5F0\uACB0 \uD14C\uC2A4\uD2B8").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      button.setButtonText("Testing...");
      const isConnected = await this.plugin.apiClient.checkStatus();
      if (isConnected) {
        button.setButtonText("\u2705 Connected");
      } else {
        button.setButtonText("\u274C Failed");
      }
      setTimeout(() => button.setButtonText("Test Connection"), 2e3);
    }));
    containerEl.createEl("h3", { text: "\uC0AC\uC6A9 \uBC29\uBC95" });
    const helpList = containerEl.createEl("ol");
    helpList.createEl("li", { text: '\uD130\uBBF8\uB110\uC5D0\uC11C "ana serve" \uC2E4\uD589' });
    helpList.createEl("li", { text: "\uB178\uD2B8\uB97C \uC5F4\uACE0 Command Palette (Ctrl/Cmd + P) \uC2E4\uD589" });
    helpList.createEl("li", { text: '"ANA: Process Current Note" \uC120\uD0DD' });
    helpList.createEl("li", { text: "\uC9C8\uBB38\uC5D0 \uB2F5\uBCC0\uD558\uC5EC Atomic Note \uC0DD\uC131" });
  }
};

// modal.ts
var import_obsidian2 = require("obsidian");
var QuestionModal = class extends import_obsidian2.Modal {
  constructor(app, questions, onSubmit, onCancel) {
    super(app);
    this.answers = [];
    this.questions = questions;
    this.answers = new Array(questions.length).fill("");
    this.onSubmit = onSubmit;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u{1F914} \uCD94\uAC00 \uC815\uBCF4\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4" });
    contentEl.createEl("p", {
      text: "\uB354 \uC88B\uC740 Atomic Note\uB97C \uC0DD\uC131\uD558\uAE30 \uC704\uD574 \uC9C8\uBB38\uC5D0 \uB2F5\uD574\uC8FC\uC138\uC694.",
      cls: "ana-modal-description"
    });
    const form = contentEl.createEl("div", { cls: "ana-question-form" });
    this.questions.forEach((question, index) => {
      const questionDiv = form.createEl("div", { cls: "ana-question-item" });
      if (question.category && question.category !== "general") {
        questionDiv.createEl("span", {
          text: question.category,
          cls: "ana-category-badge"
        });
      }
      questionDiv.createEl("label", {
        text: `Q${index + 1}. ${question.text}`,
        cls: "ana-question-label"
      });
      const textarea = questionDiv.createEl("textarea", {
        cls: "ana-answer-input",
        attr: {
          placeholder: "\uB2F5\uBCC0\uC744 \uC785\uB825\uD558\uC138\uC694... (\uC120\uD0DD\uC0AC\uD56D)",
          rows: "3"
        }
      });
      textarea.addEventListener("input", (e) => {
        this.answers[index] = e.target.value;
      });
    });
    const buttonDiv = contentEl.createEl("div", { cls: "ana-modal-buttons" });
    const cancelBtn = buttonDiv.createEl("button", {
      text: "Cancel",
      cls: "ana-btn ana-btn-secondary"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
      this.onCancel();
    });
    const submitBtn = buttonDiv.createEl("button", {
      text: "Submit Answers",
      cls: "ana-btn ana-btn-primary"
    });
    submitBtn.addEventListener("click", () => {
      this.close();
      this.onSubmit(this.answers);
    });
    const skipBtn = buttonDiv.createEl("button", {
      text: "Skip Questions",
      cls: "ana-btn"
    });
    skipBtn.addEventListener("click", () => {
      this.close();
      this.onSubmit(this.answers.map(() => ""));
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var PreviewModal = class extends import_obsidian2.Modal {
  constructor(app, draftNote, onSave, onEdit, onCancel) {
    super(app);
    this.draftNote = draftNote;
    this.onSave = onSave;
    this.onEdit = onEdit;
    this.onCancel = onCancel;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u{1F4DD} \uC0DD\uC131\uB41C Atomic Note" });
    contentEl.createEl("h3", {
      text: this.draftNote.title,
      cls: "ana-preview-title"
    });
    if (Object.keys(this.draftNote.frontmatter).length > 0) {
      const fmDiv = contentEl.createEl("div", { cls: "ana-frontmatter-preview" });
      fmDiv.createEl("strong", { text: "Frontmatter:" });
      const fmPre = fmDiv.createEl("pre");
      fmPre.setText(JSON.stringify(this.draftNote.frontmatter, null, 2));
    }
    const previewDiv = contentEl.createEl("div", { cls: "ana-content-preview" });
    await import_obsidian2.MarkdownRenderer.render(
      this.app,
      this.draftNote.content,
      previewDiv,
      "",
      new import_obsidian2.Component()
    );
    const buttonDiv = contentEl.createEl("div", { cls: "ana-modal-buttons" });
    const cancelBtn = buttonDiv.createEl("button", {
      text: "Cancel",
      cls: "ana-btn ana-btn-secondary"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
      this.onCancel();
    });
    const editBtn = buttonDiv.createEl("button", {
      text: "Edit in New Note",
      cls: "ana-btn"
    });
    editBtn.addEventListener("click", () => {
      this.close();
      this.onEdit();
    });
    const saveBtn = buttonDiv.createEl("button", {
      text: "Save Note",
      cls: "ana-btn ana-btn-primary"
    });
    saveBtn.addEventListener("click", () => {
      this.close();
      this.onSave();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AnalysisModal = class extends import_obsidian2.Modal {
  constructor(app, concepts, category, splitSuggestions, onContinue, onSplit) {
    super(app);
    this.concepts = concepts;
    this.category = category;
    this.splitSuggestions = splitSuggestions;
    this.onContinue = onContinue;
    this.onSplit = onSplit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u{1F4CA} \uBD84\uC11D \uACB0\uACFC" });
    const conceptsDiv = contentEl.createEl("div", { cls: "ana-analysis-section" });
    conceptsDiv.createEl("strong", { text: "\uAC10\uC9C0\uB41C \uAC1C\uB150:" });
    const conceptsList = conceptsDiv.createEl("ul");
    this.concepts.forEach((concept) => {
      conceptsList.createEl("li", { text: concept });
    });
    contentEl.createEl("p", { text: `\uCE74\uD14C\uACE0\uB9AC: ${this.category}` });
    if (this.splitSuggestions.length > 0) {
      contentEl.createEl("h3", { text: "\u26A0\uFE0F \uC5EC\uB7EC \uAC1C\uB150\uC774 \uAC10\uC9C0\uB418\uC5C8\uC2B5\uB2C8\uB2E4" });
      contentEl.createEl("p", { text: "\uB178\uD2B8\uB97C \uBD84\uB9AC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?" });
      const splitDiv = contentEl.createEl("div", { cls: "ana-split-options" });
      this.splitSuggestions.forEach((suggestion) => {
        const btn = splitDiv.createEl("button", {
          text: suggestion,
          cls: "ana-btn ana-split-btn"
        });
        btn.addEventListener("click", () => {
          this.close();
          this.onSplit(suggestion);
        });
      });
    }
    const buttonDiv = contentEl.createEl("div", { cls: "ana-modal-buttons" });
    const continueBtn = buttonDiv.createEl("button", {
      text: "Continue with Full Note",
      cls: "ana-btn ana-btn-primary"
    });
    continueBtn.addEventListener("click", () => {
      this.close();
      this.onContinue();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var ANAPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.currentSessionId = null;
  }
  async onload() {
    await this.loadSettings();
    this.apiClient = new ANAApiClient(this.settings.serverUrl);
    this.addRibbonIcon("brain", "ANA: Process Note", async () => {
      await this.processCurrentNote();
    });
    this.addCommand({
      id: "process-current-note",
      name: "Process Current Note",
      editorCallback: async (editor, view) => {
        await this.processCurrentNote();
      }
    });
    this.addCommand({
      id: "process-selection",
      name: "Process Selected Text",
      editorCallback: async (editor, view) => {
        const selection = editor.getSelection();
        if (selection) {
          await this.processContent(selection, "Selection");
        } else {
          new import_obsidian3.Notice("No text selected");
        }
      }
    });
    this.addCommand({
      id: "check-server",
      name: "Check Server Connection",
      callback: async () => {
        await this.checkServerConnection();
      }
    });
    this.addSettingTab(new ANASettingTab(this.app, this));
  }
  onunload() {
    if (this.currentSessionId) {
      this.apiClient.deleteSession(this.currentSessionId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.apiClient = new ANAApiClient(this.settings.serverUrl);
  }
  /**
   * Check server connection and show result
   */
  async checkServerConnection() {
    new import_obsidian3.Notice("Checking ANA server connection...");
    const isConnected = await this.apiClient.checkStatus();
    if (isConnected) {
      new import_obsidian3.Notice("\u2705 ANA server is running");
    } else {
      new import_obsidian3.Notice('\u274C Cannot connect to ANA server. Make sure to run "ana serve"');
    }
  }
  /**
   * Process the current note
   */
  async processCurrentNote() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      new import_obsidian3.Notice("No active markdown note");
      return;
    }
    const content = activeView.editor.getValue();
    const file = activeView.file;
    const title = (file == null ? void 0 : file.basename) || "Untitled";
    await this.processContent(content, title);
  }
  /**
   * Process content through ANA pipeline
   */
  async processContent(content, title) {
    var _a;
    const isConnected = await this.apiClient.checkStatus();
    if (!isConnected) {
      new import_obsidian3.Notice('\u274C ANA server not running. Run "ana serve" in terminal.');
      return;
    }
    new import_obsidian3.Notice("\u{1F504} Processing note...");
    try {
      const response = await this.apiClient.processNote(content, void 0, title);
      this.currentSessionId = response.session_id;
      if (((_a = response.analysis) == null ? void 0 : _a.should_split) && response.analysis.split_suggestions.length > 0) {
        await this.handleAnalysis(response, content);
        return;
      }
      await this.handleResponse(response);
    } catch (error) {
      new import_obsidian3.Notice(`\u274C Error: ${error.message}`);
      this.currentSessionId = null;
    }
  }
  /**
   * Handle analysis with split options
   */
  async handleAnalysis(response, originalContent) {
    if (!response.analysis) return;
    const modal = new AnalysisModal(
      this.app,
      response.analysis.detected_concepts,
      response.analysis.category,
      response.analysis.split_suggestions,
      // Continue with full note
      async () => {
        await this.handleResponse(response);
      },
      // Split by topic
      async (topic) => {
        new import_obsidian3.Notice(`Splitting for: ${topic}`);
        await this.handleResponse(response);
      }
    );
    modal.open();
  }
  /**
   * Handle response (questions or completion)
   */
  async handleResponse(response) {
    if (response.status === "needs_info" && response.questions.length > 0) {
      const modal = new QuestionModal(
        this.app,
        response.questions,
        // On submit
        async (answers) => {
          await this.submitAnswers(answers);
        },
        // On cancel
        () => {
          this.cleanupSession();
          new import_obsidian3.Notice("Processing cancelled");
        }
      );
      modal.open();
    } else if (response.status === "completed" && response.draft_note) {
      if (this.settings.showPreview) {
        await this.showPreview(response.draft_note);
      } else if (this.settings.autoSave) {
        await this.saveNote();
      } else {
        await this.createNoteInObsidian(response.draft_note);
      }
    }
  }
  /**
   * Submit answers and continue processing
   */
  async submitAnswers(answers) {
    if (!this.currentSessionId) return;
    new import_obsidian3.Notice("\u{1F504} Processing answers...");
    try {
      const response = await this.apiClient.answerQuestions(this.currentSessionId, answers);
      await this.handleResponse(response);
    } catch (error) {
      new import_obsidian3.Notice(`\u274C Error: ${error.message}`);
      this.cleanupSession();
    }
  }
  /**
   * Show preview modal
   */
  async showPreview(draftNote) {
    const modal = new PreviewModal(
      this.app,
      draftNote,
      // On save
      async () => {
        await this.saveNote();
      },
      // On edit (create in Obsidian)
      async () => {
        await this.createNoteInObsidian(draftNote);
      },
      // On cancel
      () => {
        this.cleanupSession();
      }
    );
    modal.open();
  }
  /**
   * Save note via API
   */
  async saveNote() {
    if (!this.currentSessionId) return;
    try {
      const result = await this.apiClient.saveNote(this.currentSessionId);
      if (result.success) {
        new import_obsidian3.Notice(`\u2705 Note saved: ${result.path}`);
      } else {
        new import_obsidian3.Notice(`\u274C Save failed: ${result.message}`);
      }
    } catch (error) {
      new import_obsidian3.Notice(`\u274C Error saving: ${error.message}`);
    } finally {
      this.cleanupSession();
    }
  }
  /**
   * Create note directly in Obsidian
   */
  async createNoteInObsidian(draftNote) {
    try {
      let content = "";
      if (Object.keys(draftNote.frontmatter).length > 0) {
        content += "---\n";
        for (const [key, value] of Object.entries(draftNote.frontmatter)) {
          if (Array.isArray(value)) {
            content += `${key}:
`;
            value.forEach((v) => content += `  - ${v}
`);
          } else {
            content += `${key}: ${value}
`;
          }
        }
        content += "---\n\n";
      }
      content += draftNote.content;
      const fileName = `${draftNote.title}.md`;
      const file = await this.app.vault.create(fileName, content);
      await this.app.workspace.getLeaf().openFile(file);
      new import_obsidian3.Notice(`\u2705 Created: ${fileName}`);
    } catch (error) {
      if (error.message.includes("already exists")) {
        new import_obsidian3.Notice(`\u274C File already exists: ${draftNote.title}.md`);
      } else {
        new import_obsidian3.Notice(`\u274C Error creating file: ${error.message}`);
      }
    } finally {
      this.cleanupSession();
    }
  }
  /**
   * Cleanup session
   */
  cleanupSession() {
    if (this.currentSessionId) {
      this.apiClient.deleteSession(this.currentSessionId);
      this.currentSessionId = null;
    }
  }
};
